<h4>Getting Started With Qmix</h4>
<p>
  It's pretty simple to get started with Qmix, but you'll want to install a few things to make development easier.
</p>

<h5>Regtest Mode</h5>
<p>
  It's necessary to have a Qtum node running in order to deploy contracts to the network. When developing contracts, we usually recommend running a node in regtest mode, a private development mode that allows you to quickly test contracts and transactions before deploying them to the Qtum testnet or mainnet.
</p>
<p>
  The easiest way to spin up a regtest node is to use qtumportal, a prebuilt regtest environment with a web interface. We're going to use docker to speed things up.
</p>
<pre>{{ helpCommands['docker'] }}</pre>
<p>
  To make sure we have enough Qtum to deploy contracts, we also want to generate a few blocks. In another terminal, enter the following commands:
</p>
<pre>{{ helpCommands['generateInitial'] }}</pre>
<p>
  Now we're ready to start building and deploying our contracts.
</p>

<h5>Building Contracts</h5>
<p>
  Qtum uses the Ethereum Virtual Machine, so smart contracts are written in Solidity. The best way to learn to write smart contracts is to read the <a href="https://solidity.readthedocs.io/en/develop/" target="_blank">documentation</a>.
</p>

<h5>Compiling/Debugging</h5>
<p>
  Contracts automatically compile as you write and save them, so you won't have to worry about manually compiling things. If you want to turn this off, head over to the compilation tab.
</p>
<p>
  The compilation tab will show you any errors or warnings that the Solidity compiler spits out. You can change the current compiler version by selecting a new version from the dropdown in the compilation tab.
</p>

<h5>Deploying Contracts</h5>
<p>
  Once you've written your contract, you'll probably want to deploy it and test the contract methods out. To do this, head over to the deploy/run tab. Here, you'll see an input field called "Qtum RPC URL" and a dropdown that contains the contracts of whatever file you currently have open.
</p>
<p>
  The Qtum RPC URL input should point to the RPC URL of your node. If you used the above docker command to launch your Qtum regtest node, then that URL should match the default http://qtum:test@localhost:9888.
</p>
<p>
  To deploy a contract, you'll first need to supply any constructor arguments you specified. These arguments are entered as a comma separated string. Then, you can hit the "deploy" button to deploy your contract to your Qtum node.
</p>
<p>
  Once you hit "deploy", you'll see a message in the terminal telling you that Qmix is "waiting for approval". This just means that you need to approve the transaction before it can complete. If you're using the above docker command, you can head over to http://localhost:9899 to see a list of pending transactions. Hit the "approve" button to approve the transaction.
</p>
<p>
  Now, you should see a terminal log telling you that your contract has been deployed. You should also see your contract pop up in the run tab. This means you can start to send transactions and make contract calls.
</p>

<h5>Sending Transactions</h5>
<p>
  Qmix allows you to test your contracts by sending transactions and making contract calls. All you need to do is enter arguments into the method's input field and hit the method's respective button. 
</p>
<p>
  If you're making a transaction that changes state on Qtum, you'll need to approve the transaction just like you approved the contract deployment. Again, if you're using the docker command provided above you can approve transactions at http://localhost:9899.
</p>
<p>
  You might get an error saying that the contract doesn't exist (Error: [-5] contract address does not exist). This just means that the transaction that created the contract hasn't been mined yet. Head back to your qcli terminal and enter: 
</p>
<pre>{{ helpCommands['generateOne'] }}</pre>
<p>
  to generate a single block and mine the transaction that created the contract. You'll also want to do this every time you send a transaction that changes state (transactions that require approval) in order to quickly see the result and events generated by that transaction.
</p>

<h5>Known Bugs & Other Weird Stuff</h5>
<ul>
  <li>- Currently, "send" transactions (ones that change state) don't return a value. We're working on it.</li>
  <li>- When you're making a "call" transaction, msg.sender is always set to 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.</li>
</ul>
